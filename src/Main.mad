import IO from "IO"
import { Just, Nothing } from 'Maybe'
import type { Maybe } from 'Maybe'
// import type { Element } from 'MadUI'
import {} from 'Number'
import { split } from 'String'
import { includes, tail, filter, nth, len, find } from 'List'
import { equals, identity, ifElse, always, notEquals, any } from 'Function'
import { lt } from 'Compare'
// import { fst } from 'Tuple'

import { startsWith } from './String'
import { addIndex } from './Function'

imap = addIndex(map)

/**
 * LocationParts type
 * @since 0.0.1
 */
alias LocationParts = List String

// !TODO: change when nullary functions land
getLocation = (_) => #- window.location.pathname -#

// applyRelativeTo :: a -> (b -> c) -> List b -> c
// applyRelativeTo = (that, fn, xs) => #- fn.apply(that, xs) -#
// apply = applyRelativeTo(null)

/**
 * RouteView type
 * @since 0.0.1
 */
export alias RouteView = {
  path :: String
}

routeSegments :: String -> LocationParts
routeSegments = pipe(
  split('/'),
  tail
)

initialPath :: RouteView -> LocationParts
initialPath = pipe(
  .path,
  routeSegments
)

/**
 * Match type
 * @since 0.0.1
 */
export type Match String = ExplicitMatch(String)
                         | WildcardMatch(String)
                         | NoMatch


// matchRoutes :: LocationParts -> List (Match String)
matchRoutes = (routes, given) => map(
  (x) => startsWith(':', x)
    ? WildcardMatch(x)
    : x != '' && includes(x, given)
      ? ExplicitMatch(x)
      : NoMatch
)(routes)

testURI :: List RouteView -> LocationParts -> List (List (Match String))
export testURI = (routes, given) => map(
  pipe(
    initialPath,
    matchRoutes($, given)
  )
)(routes)

/**
 * Convert a Match to a Boolean
 *
 * @since 0.0.1
 * @example
 * matchToBoolean(WildcardMatch('*')) // true
 * matchToBoolean(ExplicitMatch('name')) // true
 * matchToBoolean(NoMatch) // false
 */
matchToBoolean :: Match(String) -> Boolean
matchToBoolean = (x) => pipe(
  where {
    ExplicitMatch(_) => true
    WildcardMatch(_) => true
    NoMatch => false
  }
)(x)

/**
 * Given a list of routes and a location array, return a Boolean
 *
 * @since 0.0.1
 * @example
 * SAMPLES = [{path: '/cool'}]
 * matchesURI(SAMPLES, '/cool') // true
 */
matchesURI :: List RouteView -> LocationParts -> Boolean
export matchesURI = (routes, given) => pipe(
  testURI(routes),
  any(any(matchToBoolean))
)(given)

decodeURI = (x) => #- decodeURIComponent(x) -#

/**
 * Given a list of routes and a location array, return a List of Lists of Matches
 *
 * @since 0.0.1
 * @example
 * SAMPLES = [{path: '/cool'}]
 * transformPathToParams(SAMPLES, '/cool') // ExplicitMatch('/cool')
 */
// transformPathToParams :: List RouteView -> LocationParts -> List (List 
transformPathToParams = (routes, given) => pipe(
  map(pipe(
    initialPath,
    ifElse(
      pipe(len, equals(len(given))),
      matchRoutes($, given),
      always([NoMatch])
    )
  ))
)(routes)

stringTail = (x) => #- x.slice(1, Infinity) -#



/**
 * Produce a list of matched routes
 * 
 * @since 0.0.1
 */
// instigate :: List RouteView -> String -> List (List {given :: List String, segments :: Match(String) })
export instigate = (routes, locationPath) => pipe(
  routeSegments,
  (given) => ifElse(
    matchesURI(routes),
    pipe(
      transformPathToParams(routes),
      filter(any(matchToBoolean)),
      chain(imap((m, i) => pipe(
          where {
            ExplicitMatch(x) => Just({kind: 'explicit', match: x, value: x})
            WildcardMatch(e) => pipe(
              nth(i),
              map((y) => ({ kind: 'wildcard', match: e, value: y }))
            )(given)
            NoMatch => Nothing
          }
        )(m)
      )),
      map(where {
        Just(x) => x
        Nothing => ({kind: 'nothing', match: 'none', value: ''})
      })
    ),
    always([]),
    given
  )
)(locationPath)

SAMPLE = [
  { path: '/zeta' },
  { path: '/alpha/beta' },
  { path: '/gamma/delta/:epsilon' },
  { path: '/name/:name/detail/:detail' }
]

j2 = (x) => #- JSON.stringify(x, null, 2) -#

testInstigate = pipe(
  instigate(SAMPLE)
  // j2,
  // IO.trace('instigated')
)

hex :: String -> String
hex = (r) => (
  'hsla(' ++ r ++ ', 100%, 50%, 1)'
)
random :: Number -> Number
random = (x) => #- Math.random() * x -#

randomHex :: Number -> String
randomHex = (_) => pipe(
  random,
  show,
  hex
)(360)


#-
  if (typeof window !== 'undefined') {
    window.onload = () => {
      console.log('RUNNING!', new Date())
      console.log("SAMPLE DATA", JSON.stringify(SAMPLE, null, 2))
      console.log('here', getLocation())
      console.log('instigate / ', testInstigate(getLocation()))
      console.log('instigate /alpha', testInstigate('/alpha'))
      console.log('instigate /alpha/beta', testInstigate('/alpha/beta'))
      console.log('instigate /gamma/delta/cool', testInstigate('/gamma/delta/cool'))
      console.log('instigate /name/brekk/detail/testing', testInstigate('/name/brekk/detail/testing'))
      console.log('instigator /name/brekk/detail/cool', instigate(SAMPLE)('/name/brekk/detail/cool'))
      document.body.style.background = randomHex(false)
    }
  }
-#

#-
{Browser}
  window.instigate = instigate
  // window.traceOnce = traceOnce
  window.testURI = testURI
  window.matchesURI = matchesURI
  window.matchRoutes = matchRoutes
{/Browser}
-#

