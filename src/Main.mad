import IO from "IO"
import { Just, Nothing } from 'Maybe'
// import type { Maybe } from 'Maybe'
// import type { Element } from 'MadUI'
import {} from 'Number'
import { split } from 'String'
import {
  reject,
  first,
  last,
  includes,
  tail,
  filter,
  nth,
  len,
  join,
  find,
  reduce
} from 'List'
import {
  equals,
  identity,
  ifElse,
  always,
  any
} from 'Function'
import { lt } from 'Compare'

import { startsWith } from './String'
import { addIndex } from './Function'

imap = addIndex(map)

/**
 * LocationParts type
 * @since 0.0.1
 */
alias LocationParts = List String

// !TODO: change when nullary functions land
getLocation :: () -> String
getLocation = (_) => #- window.location.pathname -#

decodeURI :: String -> String
decodeURI = (x) => #- decodeURIComponent(x) -#

/**
 * RouteView type
 * @since 0.0.1
 */
export alias RouteView = {
  path :: String,
  callback :: a -> b
}

slashes = split('/')

routeSegments :: String -> LocationParts
routeSegments = ifElse(
  startsWith('/'),
  pipe(slashes, tail),
  slashes
)

initialPath :: RouteView -> LocationParts
initialPath = pipe(
  .path,
  routeSegments
)

/**
 * Match type
 * @since 0.0.1
 */
export type Match String = ExplicitMatch(String)
                         | WildcardMatch(String)
                         | NoMatch


isWildcard = startsWith(':')

matchRoutes :: List String -> LocationParts -> List (Match String)
matchRoutes = (routes, given) => map(
  (x) => isWildcard(x)
    ? WildcardMatch(x)
    : x != '' && includes(x, given)
      ? ExplicitMatch(x)
      : NoMatch
)(routes)

testURI :: List RouteView -> LocationParts -> List (List (Match String))
export testURI = (routes, given) => map(
  pipe(
    initialPath,
    matchRoutes($, given)
  )
)(routes)

/**
 * Convert a Match to a Boolean
 *
 * @since 0.0.1
 * @example
 * matchToBoolean(WildcardMatch('*')) // true
 * matchToBoolean(ExplicitMatch('name')) // true
 * matchToBoolean(NoMatch) // false
 */
matchToBoolean :: Match(String) -> Boolean
matchToBoolean = (
  where {
    ExplicitMatch(_) => true
    WildcardMatch(_) => true
    NoMatch => false
  }
)

export type DiscreteMatch String Number
  = DiscreteExplicitMatch(String, Number)
  | DiscreteWildcardMatch(String, String, Number)
  | DiscreteNoMatch(Number)

/**
 * Convert a DiscreteMatch to a Boolean
 *
 * @since 0.0.1
 * @example
 * discreteMatchToBoolean(DiscreteWildcardMatch('*')) // true
 * discreteMatchToBoolean(DiscreteExplicitMatch('name')) // true
 * discreteMatchToBoolean(DiscreteNoMatch) // false
 */
discreteMatchToBoolean :: (DiscreteMatch String Number) -> Boolean
discreteMatchToBoolean = (
  where {
    DiscreteExplicitMatch(x, i)    => true
    DiscreteWildcardMatch(x, y, i) => true
    DiscreteNoMatch(i)             => false
  }
)

/**
 * Given a list of routes and a location array, return a Boolean
 *
 * @since 0.0.1
 * @example
 * SAMPLES = [{path: '/cool'}]
 * matchesURI(SAMPLES, '/cool') // true
 */
matchesURI :: List RouteView -> LocationParts -> Boolean
export matchesURI = (routes, given) => pipe(
  testURI(routes),
  any(any(matchToBoolean))
)(given)

/**
 * Given a list of routes and a location array, return a List of Lists of Matches
 *
 * @since 0.0.1
 * @example
 * SAMPLES = [{path: '/cool'}]
 * transformPathToParams(SAMPLES, '/cool') // ExplicitMatch('/cool')
 */
transformPathToParams :: List RouteView -> LocationParts -> List (List (Match String))
transformPathToParams = (routes, given) => pipe(
  map(pipe(
    initialPath,
    ifElse(
      pipe(len, (x) => x >= len(given)),
      matchRoutes($, given),
      always([NoMatch])
    )
  ))
)(routes)

stringTail = (x) => #- x.slice(1, Infinity) -#

/**
 * Given a Match, convert it to a Discrete Match (which has additional index data)
 *
 * @since 0.0.1
 */
matchToDiscreteMatch :: LocationParts -> List (List (Match String)) -> List (List (DiscreteMatch String Number))
matchToDiscreteMatch = (given, routes) => pipe(
  map(imap((m, index) => pipe(
    where {
      ExplicitMatch(x) => Just(
        DiscreteExplicitMatch(x, index)
      )
      WildcardMatch(match) => pipe(
        nth(index),
        map((value) => (
          DiscreteWildcardMatch(match, value, index)
        ))
      )(given)
      NoMatch => Nothing
    },
    where {
      Just(x) => x
      Nothing => DiscreteNoMatch(index)
    }
  )(m)))
)(routes)

maybeToDiscreteMatch = (
  where {
    Just(x) => discreteMatchToBoolean(x)
    Nothing => false
  }
)

skipLeadingNoMatch = filter(pipe(
  first,
  maybeToDiscreteMatch
))
skipTrailingNoMatch = filter(pipe(
  last,
  maybeToDiscreteMatch 
))

discreteMatchToIdentifiers = (
  where {
    DiscreteExplicitMatch(x, i)    => x
    DiscreteWildcardMatch(k, v, i) => k
    DiscreteNoMatch(i)             => ''
  }
)

tailString = (x) => #- x.slice(1) -#

discreteMatchToParams = (
  where {
    DiscreteExplicitMatch(value, _)      => ({key: 'explicit', value})
    DiscreteWildcardMatch(key, value, _) => ({key: tailString(key), value})
    DiscreteNoMatch(_)                   => ({key: 'no-match', value: ''})
  }
)

/**
 * If you have a route like `a/b/:c` but are given an `/a` route to match, `/a` is not valid by itself.
 * Since it seems possible that you may have wanted a match, here's a warning.
 *
 * @since 0.0.1
 */
warnOnPartialMatches :: List (List (DiscreteMatch String Number)) -> List (List (DiscreteMatch String Number))
warnOnPartialMatches = (given) => pipe(
  reject(pipe(
    last,
    maybeToDiscreteMatch
  )),
  map(pipe(
    map(discreteMatchToIdentifiers),
    filter((z) => z != ''),
    join('/'),
    (matched) => '/' ++ matched,
    IO.trace('There is a partially matchable route which is not explicitly defined but could be:')
  )),
  (_) => skipTrailingNoMatch(given)
)(given)

alias Config = {
  warnOnPartialMatches :: Boolean
}

NO_ROUTE_MATCHED = 'NO_ROUTE_MATCHED'
UNMATCHED_ROUTE = {
  path: NO_ROUTE_MATCHED,
  callback: (x, _) => x
}

merge :: a -> b -> c
merge = (a, b) => #- Object.assign({}, a, b) -#

objOf :: String -> a -> b
objOf = (a, b) => #- ({[a]: b}) -#

/**
 * Produce a list of matched routes
 * 
 * @since 0.0.1
 */
// instigate :: Config -> List RouteView -> String -> List String
export instigate = (config, routes, locationPath) => pipe(
  routeSegments,
  (given) => ifElse(
    matchesURI(routes),
    pipe(
      transformPathToParams(routes),
      matchToDiscreteMatch(given),
      skipLeadingNoMatch,
      config.warnOnPartialMatches
           ? warnOnPartialMatches
           : skipTrailingNoMatch,
      chain(identity),
      (raw) => pipe(
        map(pipe(
          discreteMatchToIdentifiers
        )),
        join('/'),
        (matched) => pipe(
          find(pipe(
            .path,
            (x) => equals('/' ++ matched, x) || equals(matched, x)
          )),
          where {
            Just(x) => pipe(
              filter(where {
                DiscreteExplicitMatch(a, _) => false
                DiscreteWildcardMatch(a, b, _) => true
                DiscreteNoMatch(_) => false
              }),
              map(discreteMatchToParams),
              reduce((agg, item) => merge(agg, objOf(item.key, item.value)), {}),
              IO.trace('raw'),
              x.callback,
              (_) => true
            )(raw)
            Nothing => false
          }
        )(routes)
      )(raw)
    ),
    always(false)
  )(given)
)(locationPath)

hex :: String -> String
hex = (r) => (
  'hsla(' ++ r ++ ', 100%, 50%, 1)'
)
random :: Number -> Number
random = (x) => #- Math.random() * x -#

randomHex :: Number -> String
randomHex = (_) => pipe(
  random,
  show,
  hex
)(360)

callback = IO.trace('SO COOL')

querySelector = (x) => #- document.querySelector(x) -#

epsilonCallback = (params) => pipe(
  querySelector,
  (el) => #-{
    el.style.background = randomHex(false)
    el.textContent = JSON.stringify(params, null, 2)
  }-#
)('#app')

SAMPLE = [
  { path: '/zeta', callback },
  { path: 'alpha/beta', callback },
  { path: 'gamma/delta/:epsilon',
    callback: epsilonCallback
  },
  { path: '/name/:name/detail/:detail', callback }
]

j2 = (x) => #- JSON.stringify(x, null, 2) -#
CONFIG = {warnOnPartialMatches: true}
testInstigate = pipe(
  instigate(CONFIG, SAMPLE)
  // j2,
  // IO.trace('instigated')
)


#-
  if (typeof window !== 'undefined') {
    window.onload = () => {
      console.log('RUNNING!', new Date())
      console.log("SAMPLE DATA", JSON.stringify(SAMPLE, null, 2))
      console.log('here', getLocation())
      console.log('instigate / ', testInstigate(getLocation()))
      /*
      console.log('instigate /alpha', testInstigate('/alpha'))
      console.log('instigate alpha/beta', testInstigate('alpha/beta'))
      console.log('instigate /alpha/beta', testInstigate('/alpha/beta'))
      console.log('instigate /gamma/delta/cool', testInstigate('/gamma/delta/cool'))
      console.log('instigate /name/brekk/detail/testing', testInstigate('/name/brekk/detail/testing'))
      console.log('instigate /name/brekk', testInstigate('/name/brekk'))
      console.log('instigator /name/brekk/detail/cool', instigate(CONFIG)(SAMPLE)('/name/brekk/detail/cool'))
      */
      document.body.style.background = randomHex(false)
    }
  }
-#

#-
{Browser}
  window.instigate = instigate
  // window.traceOnce = traceOnce
  window.testURI = testURI
  window.matchesURI = matchesURI
  window.matchRoutes = matchRoutes
{/Browser}
-#

