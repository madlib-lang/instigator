/* !TODO - move this to prelude/Function */
addIndex :: ((a -> b) -> c -> d) -> (a -> Number -> b) -> c -> d
export addIndex = (fn, y, xs) => {
  i = 0
  return fn(
    (x) => {
      result = y(x, i)
      i = i + 1
      return result 
    },
    xs
  )
}

/*
imap = addIndex(map)
ifilter = addIndex(filter)

// !TODO - move this to prelude/Function tests
IO.trace(
  'imap',
  imap((x, i) => `${x}${show(i)}`, ['a', 'b', 'c'])
)

IO.trace(
  'ifilter',
  ifilter(
    (_, i) => i > 1,
    ['a', 'b', 'c', 'd']
  )
)

export type OnceStatus
  = CalledBinary(a, b, c)
  | Called(a, b)
  | Stasis

once = (fn) => {
  status = Stasis
  result = ()
  arity1 = (a) => (
    if (status == Called) {
      result
    } else {
      status = Called
      result = fn(a)
    }
  )
  return arity1
}
once2 = (fn) => {
  status = Stasis
  changeStatus = (a, b) => {
    status = CalledBinary(a, b, fn(a, b))
    return status
  }
  arity2 = (a, b) => pipe(
    where {
      Stasis => changeStatus(a, b)
      CalledBinary(_, _, cache) => cache  
    }
  )(status)
  return arity2
}
*/

export once2 = (fn) => #-{
  const cache = { set: false }
  return function binary(a) { return function unary(b) {
    if (cache.set) return cache.value
    cache.set = true
    cache.value = fn(a)(b)
    return cache.value
  } }
}-#
/*
traceOnce = once2(IO.trace)
traceOnce('hey', 'there')
traceOnce('a', 'b')
traceOnce('x', 'y')
*/
